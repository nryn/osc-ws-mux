import WebSocket,{WebSocketServer}from"ws";import readline from"readline";import osc from"osc";import fs from"fs";const defaults={localAddress:"0.0.0.0",websocketBroadcastPort:8080,udpBroadcastPort:57122,oscDestinationAddress:"0.0.0.0",oscDestinationPort:"9001",oscReceiverPort:57121,broadcastIntervalInMs:100};export default class Broadcaster{constructor({localAddress:s=defaults.localAddress,websocketBroadcastPort:t=defaults.websocketBroadcastPort,udpBroadcastPort:e=defaults.udpBroadcastPort,oscDestinationAddress:r=defaults.oscDestinationAddress,oscDestinationPort:o=defaults.oscDestinationPort,oscReceiverPort:i=defaults.oscReceiverPort,broadcastIntervalInMs:a=defaults.broadcastIntervalInMs}=defaults){this.localAddress=s,this.websocketBroadcastPort=t,this.oscReceiverPort=i,this.udpBroadcastPort=e,this.oscDestinationAddress=r,this.oscDestinationPort=o,this.broadcastIntervalInMs=a,this.oscRelayEnabled=!1,this.udpPort=null,this.udpReady=!1,this.udpLastErrorTimestamp=null,this.wss=null,this.websocketReady=!1,this.savedMessages={},this.msgCounts={},this.broadcaster=null,this.recordingInProgress=!1,this.currentRecordingFilename="default.json",this.currentRecordingData=[],this.playbackInProgress=!1,this.nowPlaying={},this.init()}init(){console.log("Setting up UDP and WSS Servers for Broadcast"),this.initUDP(),this.initWSS();let s=0,t=setInterval(()=>{const e=()=>{readline.clearLine(process.stdout),readline.cursorTo(process.stdout,0),process.stdout.write(`udpReady: ${this.udpReady} | websocketReady: ${this.websocketReady} | timeWaiting < ${s+=10}ms`)};this.udpReady&&this.websocketReady?(e(),process.stdout.write("\n"),clearInterval(t),console.log("When OSC received, will re-broadcast data..."),console.log(`...via OSC to ${this.oscDestinationAddress}:${this.oscDestinationPort} via local UDP port ${this.udpBroadcastPort}`),console.log(`...via Websockets to connected clients over port ${this.websocketBroadcastPort}`),this.setUpBroadcastAtInterval()):e()},10)}initUDP(){this.udpPort=new osc.UDPPort({localAddress:this.localAddress,localPort:this.udpBroadcastPort}),this.udpPort.open(),this.udpPort.on("error",s=>{this.udpLastErrorTimestamp=(new Date).getTime(),console.log(`UDP Error @ ${this.udpLastErrorTimestamp} :: ${s.message}`)}),this.udpPort.on("ready",()=>{this.udpReady=!0})}initWSS(){this.wss=new WebSocketServer({port:this.websocketBroadcastPort}),this.wss.on("connection",s=>{s.on("message",t=>{const e=JSON.parse(t);switch(e.type){case"loadRecordings":s.send(JSON.stringify(this.fetchRecordingsData()));break;case"playRecording":this.playRecording(e.recording);break;case"toggleRecording":this.toggleRecording(),s.send(JSON.stringify(this.currentRecordingStatus()));break;case"recordingStatus":s.send(JSON.stringify(this.currentRecordingStatus()));break;case"setIoConfig":this.setIoConfig(e.oscRelayEnabled,e.oscDestinationAddress,e.oscDestinationPort),s.send(JSON.stringify(this.currentIoConfig()));break;case"ioConfig":s.send(JSON.stringify(this.currentIoConfig()));break;case"playingStatus":s.send(JSON.stringify(this.currentPlayingStatus()));break;case"deleteRecording":this.deleteRecording(e.recording);break;default:console.log("received unknown msg: %s",t)}})}),this.websocketReady=!0}setIoConfig(s,t,e){"boolean"==typeof s&&(this.oscRelayEnabled=s),t&&(this.oscDestinationAddress=t),e&&(this.oscDestinationPort=e)}currentIoConfig(){return{type:"ioConfig",websocketBroadcastPort:this.websocketBroadcastPort,oscReceiverPort:this.oscReceiverPort,oscRelayEnabled:this.oscRelayEnabled,oscDestinationAddress:this.oscDestinationAddress,oscDestinationPort:this.oscDestinationPort}}broadcastSavedMessages(){if(!this.udpReady)throw new Error("UDP not ready");if(!this.websocketReady)throw new Error("Websocket not ready");const s=this.savedMessages;Object.keys(s).length&&(this.broadcastOverWebsocket(s),this.oscRelayEnabled&&this.broadcastOverUDP(s)),this.recordingInProgress&&this.currentRecordingData.push({...s}),this.clearMessages(s)}broadcastOverWebsocket(s){const t=JSON.stringify(s,null,2);this.wss.clients.forEach(s=>{s.readyState===WebSocket.OPEN&&s.send(t)})}broadcastOverUDP(s){for(var t in s)this.udpPort.send({address:t,args:s[t]},this.oscDestinationAddress,this.oscDestinationPort)}setUpBroadcastAtInterval(){this.broadcaster=setInterval(()=>this.broadcastSavedMessages(),this.broadcastIntervalInMs)}saveMessage({address:s,args:t},e=!1){this.playbackInProgress&&!e||(this.savedMessages[s]?this.msgCounts[s]=this.msgCounts[s]+1:this.msgCounts[s]=1,this.savedMessages[s]=t)}clearMessages(s){for(var t in s)s.hasOwnProperty(t)&&delete s[t]}stopBroadcast(){this.broadcaster&&(clearInterval(this.broadcaster),this.broadcaster=null)}fetchRecordingsData(){return{type:"recordingsData",recordings:fs.readdirSync("./recordings")||[]}}currentRecordingStatus(){return{type:"recordingStatus",isRecording:this.recordingInProgress}}currentPlayingStatus(){return{type:"playingStatus",nowPlaying:Object.entries(this.nowPlaying).reduce((s,[t,e])=>{return[...s,...e?[t]:[]]},[])}}playRecording(s){this.playbackInProgress=!0,this.nowPlaying[s]=!0;try{const t=fs.readFileSync(`./recordings/${s}`),e=JSON.parse(t);e.forEach((t,r)=>{setTimeout(()=>{Object.entries(t).forEach(([s,t])=>{this.saveMessage({address:s,args:t},!0)}),e.length===r+1&&setTimeout(()=>{this.nowPlaying[s]=!1,Object.values(this.nowPlaying).some(s=>!!s)||(this.playbackInProgress=!1)},this.broadcastIntervalInMs)},this.broadcastIntervalInMs*r)})}catch(t){return console.log("recording playback error:",t),this.nowPlaying[s]=!1,void(Object.values(this.nowPlaying).some(s=>!!s)||(this.playbackInProgress=!1))}}deleteRecording(s){try{fs.unlinkSync(`./recordings/${s}`)}catch(s){return void console.log("recording deletion error:",s)}}toggleRecording(){if(this.recordingInProgress)fs.writeFileSync(`./recordings/${this.currentRecordingFilename}`,JSON.stringify(this.currentRecordingData),"utf8"),this.currentRecordingFilename="default.json",this.currentRecordingData=[];else{const s=new Date;this.currentRecordingFilename=`${s.getUTCFullYear()}-${s.getUTCMonth()+1}-${s.getUTCDate()}_${s.getUTCHours()}:${s.getUTCMinutes()}:${s.getUTCSeconds()}.json`,this.currentRecordingData=[]}this.recordingInProgress=!this.recordingInProgress}}